
## Multi-client In-Memory Key/Value Datastore Server

The server supports single commands and transactions over a plain TCP socket connection. Both keys and values are UTF-8 strings.
It may potentially be used as a high performance cache.

_A transaction is a set of data modification commands that are updated in an “all or nothing” fashion – in that connecting clients see all the data modifications contained in a transaction that has been committed as an atomic operation._

### Commands (case insensitive) and parameters
* PUT [key] [value]
* GET [key]
* DEL [key]
* START
* COMMIT
* ROLLBACK
space is not allowed in `key`.

### Start the server
#### Directly
Make sure Python 3 is installed. Then,
```bash
python3 HausKVServer.py
```  

#### In a docker container
Run the follow command to generate a docker image.
```bash
docker build -t haus-dapeng .
```
You may check the docker image has been correctly generated by running `docker image list`.
The following command runs the server inside a docker container:
```bash
docker run -p 9888:9888 haus-dapeng
```
In the above commands, `haus-dapeng` is the name of generated image, you many replace it with any small case string you like.

---

### Connect to the Server

You can use `telnet`:

```bash
telnet localhost 9888
```

### Command and response formats
Commands are strings, while spaces are only significant inside `value` of command `PUT`. For example, <pre>`PUT   a    3 * 3 = 9 `</pre> will be interpreted as `PUT` value `3 * 3 = 9` to key `a`.

Server Responses to Commands
The server will return a JSON structure with the following keys:
* status – required, “Ok” or “Error”
* result – optional, result of a GET
* mesg - optional, additional context:  could be a human-readable message


### Examples of interaction

```text
PUT a 1
{"status": "Ok"}
GET a
{"status": "Ok", "result": "some value"}

{"status": "Error", "mesg": "Unexpected error!"}

START
GET most_popular_leader
{"status": "Ok", "result": "georgew"}
PUT georgew {"first_name": "George", "last_name": "Washington", "role": "President"}
{"status": "Ok"}
PUT winstonc {"first_name": "Winston", "last_name": "Churchill", "role": "Prime Minister"}
{"status": "Ok"}
GET georgew
{"status": "Ok", "result": "{\"first_name\": \"George\", \"last_name\": \"Washington\", \"role\": \"President\"}"}
COMMIT
```


Note:  some assumptions or requirements have been deliberately omitted from the instructions.  Please take note of any assumptions you make in your solution, along with the rationale for taking those decisions – include such notes in the README.md file.



 

---

### Design Notes

* The in-memory store is a shared Python `dict` protected by a global `threading.Lock()`.
* Each client connection runs in its own thread.
* Transactions are client-scoped and stored per-thread.
* Only one active transaction is allowed per client (no nested transactions).
* `PUT` assumes valid JSON and uses `shlex.split()` to handle flexible input formatting.

---

Let me know if you want to include performance metrics, a protocol spec, or unit tests.
